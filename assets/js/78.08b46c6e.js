(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{223:function(e,t,a){"use strict";a.r(t);var n=a(0),i=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"architecture-explanation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#architecture-explanation","aria-hidden":"true"}},[e._v("#")]),e._v(" Architecture Explanation")]),e._v(" "),a("p",[e._v("The API is completely decoupled from the application. This means that any application can (based on the settings) connect to any API. This created an interesting thought problem regarding extensions. If you setup a field to use a particular interface for example, you expect every connected application to have and use that particular interface. If we bundled the extensions into the application codebase, this wouldn’t be possible, as it would mean that every different instance of the application would have different extensions (and thus interfaces) at it’s disposal.")]),e._v(" "),a("p",[e._v("By having the interfaces in the app, we ran into another problem around custom interfaces. By having the interfaces included in the application in build-time, and the fact that the application is now a self-contained SPA, it would mean that the user has to re-build the whole application each time he/her wants to add a new extension. It would also make over-the-air installations of new extensions impossible.")]),e._v(" "),a("p",[e._v("To solve this problem, we decided to move the extensions into the API and have them served from there when they're needed in the application. To prevent confusion (and to prevent to have to build two different loaders), we decided to have the core extensions served from the API as well.")]),e._v(" "),a("p",[e._v("All extensions are “just” Vue single file component(s) with a JSON file added so the application has some additional metadata.")]),e._v(" "),a("p",[e._v("Extension types (interfaces, pages, layouts, etc) are based on a file naming scheme. Interfaces for example always contain a "),a("code",[e._v("readonly")]),e._v(" (used to statically display data) and an "),a("code",[e._v("interface")]),e._v(" component (the actual “input”).")]),e._v(" "),a("p",[e._v("Extensions are being served in bundled form from the API. In order for the API to serve them correctly, they have to be in the "),a("code",[e._v("/public/extensions")]),e._v(" folder. This folder is split up into "),a("code",[e._v("core")]),e._v(" and "),a("code",[e._v("custom")]),e._v(" which both have the same nested file structure. For example, the full path of the "),a("code",[e._v("datetime")]),e._v(" core interface would be "),a("code",[e._v("/public/extensions/core/interfaces/datetime/Interface.js")]),e._v(".")]),e._v(" "),a("p",[e._v("The application is built and bundled completely separate from the extensions and the extensions have their own build-chain setup which is currently setup in the "),a("code",[e._v("build")]),e._v(" folder in the directus/extensions repo. We plan on releasing this (little) build chain (including the Vue mixins for extensions) as a separate CLI tool later on, but that has to wait until after the main application is finished and released.")])])}],!1,null,null,null);i.options.__file="architecture.md";t.default=i.exports}}]);